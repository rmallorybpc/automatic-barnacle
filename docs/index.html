<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Automatic Barnacle Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 2rem; }
    header { margin-bottom: 1rem; }
    .status { margin: 1rem 0; padding: 0.75rem; background: #f6f8fa; border: 1px solid #d0d7de; border-radius: 6px; }
    pre { background: #f6f8fa; padding: 1rem; border-radius: 6px; overflow: auto; }
    table { border-collapse: collapse; width: 100%; margin-top: 0.75rem; }
    th, td { border: 1px solid #d0d7de; padding: 0.5rem; text-align: left; }
    th { background: #f0f3f6; }
    section { margin-top: 1.5rem; }
    .error { color: #b42318; }
    .ok { color: #1a7f37; }
    .muted { color: #57606a; }
    .tag { display:inline-block; padding:0.2rem 0.45rem; border:1px solid #d0d7de; border-radius:999px; font-size:0.85rem; margin-right:0.35rem; background:#f6f8fa; }
    .steps { background:#f6f8fa; border:1px solid #d0d7de; border-radius:6px; padding:0.75rem; }
    .toggle { font-size:0.9rem; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1rem; }
    .card { border:1px solid #d0d7de; border-radius:6px; padding:0.75rem; background:#fff; }
    .card h3 { margin-top:0; }
    .small { font-size: 0.9rem; }
  </style>
</head>
<body>
  <header>
    <h1>Automatic Barnacle Dashboard</h1>
    <p class="muted">Static site served from docs/. This page loads reports/dashboard.json when available.</p>
  </header>

  <div id="status" class="status">Loading dashboard dataâ€¦</div>

  <section id="summary" hidden>
    <h2>Summary</h2>
    <div id="summaryContent"></div>
  </section>

  <section id="featuresGaps" hidden>
    <h3>Features / Gaps</h3>
    <div id="featuresGapsContent"></div>
  </section>

  <section id="learnAlignment" hidden>
    <h2>Learn Alignment</h2>
    <p class="muted small">Grouped by Microsoft Learn categories based on sources and product areas. Use links to recommended learning paths.</p>
    <div id="learnGrid" class="grid"></div>
  </section>

  <section id="timeSeries" hidden>
    <h2>Time series</h2>
    <table id="timeSeriesTable">
      <thead>
        <tr>
          <th>Date</th>
          <th>Count</th>
          <th>Cumulative</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section id="sourceBreakdown" hidden>
    <h2>Source breakdown</h2>
    <table id="sourceBreakdownTable">
      <thead>
        <tr>
          <th>Source</th>
          <th>Count</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section id="productAreaBreakdown" hidden>
    <h2>Product area breakdown</h2>
    <table id="productAreaBreakdownTable">
      <thead>
        <tr>
          <th>Product area</th>
          <th>Count</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <section id="executive" hidden>
    <h2>Executive Summary</h2>
    <div id="executiveContent"></div>
    <div id="gapsSection" hidden>
      <h3>Gaps</h3>
      <table id="gapsTable">
        <thead>
          <tr>
            <th>Name</th>
            <th>Impact</th>
            <th>Area</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="steps" id="immediateSteps"></div>
    </div>
    <p class="toggle"><a href="#" id="toggleRaw">Show raw dashboard.json</a></p>
  </section>

  <section id="raw" hidden>
    <h2>Raw dashboard.json</h2>
    <pre id="rawJson"></pre>
  </section>

  <script>
    function safeGet(obj, path, fallback = undefined) {
      try { return path.split('.').reduce((o, k) => (o && k in o ? o[k] : undefined), obj) ?? fallback; }
      catch { return fallback; }
    }
    function renderTableRows(tbodyEl, rows, columns) {
      tbodyEl.innerHTML = '';
      if (!Array.isArray(rows) || rows.length === 0) return;
      const html = rows.map(row => '<tr>' + columns.map(col => `<td>${String(safeGet(row, col, ''))}</td>`).join('') + '</tr>').join('');
      tbodyEl.innerHTML = html;
    }
    function formatISO(ts) { return ts || ''; }

    function buildImmediateSteps(gaps) {
      if (!Array.isArray(gaps) || gaps.length === 0) {
        return '<p class="muted">No gaps detected. No immediate actions required.</p>';
      }
      const total = gaps.length;
      const impacts = gaps.reduce((acc, g) => { const level = (g.impact || 'unknown').toLowerCase(); acc[level] = (acc[level] || 0) + 1; return acc; }, {});
      const bullets = [
        impacts.high ? `Prioritize ${impacts.high} high-impact gap(s): create/assign issues today.` : '',
        impacts.medium ? `Schedule remediation for ${impacts.medium} medium-impact gap(s) within the next sprint.` : '',
        impacts.low ? `Track ${impacts.low} low-impact gap(s) for opportunistic fixes.` : ''
      ].filter(Boolean);
      return `<h4>Immediate Steps</h4><p>Detected ${total} gap(s). Recommended actions:</p><ul>${bullets.map(b => `<li>${b}</li>`).join('')}<li>Verify monitoring coverage for affected product areas and sources.</li></ul>`;
    }

    async function loadJSON(path) {
      const res = await fetch(path, { cache: 'no-store' });
      if (!res.ok) return null;
      return res.json();
    }

    function computeLearnAlignment(data, map) {
      const categories = (map && map.category_order) || [];
      const src = safeGet(data, 'source_breakdown.sources', []);
      const pa = safeGet(data, 'product_area_breakdown.product_areas', []);
      const srcMap = (map && map.source_to_category) || {};
      const paMap = (map && map.product_area_to_category) || {};
      const totals = {};

      if (Array.isArray(src)) {
        src.forEach(s => {
          const key = (s.name || '').toLowerCase();
          const cat = srcMap[key] || 'Foundational Knowledge';
          totals[cat] = (totals[cat] || 0) + (s.count || 0);
        });
      }
      if (Array.isArray(pa)) {
        pa.forEach(p => {
          const key = (p.name || '').toLowerCase();
          const cat = paMap[key] || 'Foundational Knowledge';
          totals[cat] = (totals[cat] || 0) + (p.count || 0);
        });
      }

      const result = categories.map(cat => ({
        name: cat,
        count: totals[cat] || 0,
        link: (map && map.category_links && map.category_links[cat]) || null
      }));
      Object.keys(totals).forEach(k => {
        if (!categories.includes(k)) result.push({ name: k, count: totals[k], link: null });
      });
      return result.sort((a, b) => {
        const ai = categories.indexOf(a.name); const bi = categories.indexOf(b.name);
        if (ai !== -1 && bi !== -1 && ai !== bi) return ai - bi;
        return (b.count || 0) - (a.count || 0);
      });
    }

    function renderSourceBreakdownWithLinks(tbodyEl, sources, map) {
      tbodyEl.innerHTML = '';
      if (!Array.isArray(sources) || !sources.length) return;

      const srcMap = (map && map.source_to_category) || {};
      const links = (map && map.category_links) || {};

      const rowsHtml = sources.map(s => {
        const name = s.name || '';
        const count = s.count || 0;
        const cat = srcMap[name.toLowerCase()];
        const href = cat ? links[cat] : null;
        const countCell = href
          ? `<a href="${href}" target="_blank" rel="noopener" title="Open recommended learning path for ${cat}">${count}</a>`
          : String(count);
        return `<tr><td>${name}</td><td>${countCell}</td></tr>`;
      }).join('');

      tbodyEl.innerHTML = rowsHtml;
    }

    async function loadDashboard() {
      const statusEl = document.getElementById('status');

      const summaryEl = document.getElementById('summary');
      const summaryContentEl = document.getElementById('summaryContent');

      const featuresGapsEl = document.getElementById('featuresGaps');
      const featuresGapsContentEl = document.getElementById('featuresGapsContent');

      const timeSeriesEl = document.getElementById('timeSeries');
      const timeSeriesBodyEl = document.querySelector('#timeSeriesTable tbody');

      const sourceBreakdownEl = document.getElementById('sourceBreakdown');
      const sourceBreakdownBodyEl = document.querySelector('#sourceBreakdownTable tbody');

      const productAreaBreakdownEl = document.getElementById('productAreaBreakdown');
      const productAreaBreakdownBodyEl = document.querySelector('#productAreaBreakdownTable tbody');

      const executiveEl = document.getElementById('executive');
      const executiveContentEl = document.getElementById('executiveContent');
      const gapsSectionEl = document.getElementById('gapsSection');
      const gapsBodyEl = document.querySelector('#gapsTable tbody');
      const immediateStepsEl = document.getElementById('immediateSteps');

      const learnAlignmentEl = document.getElementById('learnAlignment');
      const learnGridEl = document.getElementById('learnGrid');

      const rawEl = document.getElementById('raw');
      const rawJsonEl = document.getElementById('rawJson');
      const toggleRawEl = document.getElementById('toggleRaw');

      try {
        const [data, map] = await Promise.all([
          loadJSON('reports/dashboard.json'),
          loadJSON('reports/learn_alignment_map.json')
        ]);

        if (!data) {
          statusEl.innerHTML = `<strong class="error">dashboard.json not found</strong>. Once your pipeline runs, it will copy reports/dashboard.json into docs/reports/dashboard.json.`;
          return;
        }
        statusEl.innerHTML = `<strong class="ok">dashboard.json loaded</strong>`;

        rawJsonEl.textContent = JSON.stringify(data, null, 2);
        if (toggleRawEl) {
          toggleRawEl.addEventListener('click', (e) => {
            e.preventDefault();
            rawEl.hidden = !rawEl.hidden;
            toggleRawEl.textContent = rawEl.hidden ? 'Show raw dashboard.json' : 'Hide raw dashboard.json';
          });
        }

        // Summary
        const generatedAt = safeGet(data, 'generated_at', null);
        const totalFeatures = safeGet(data, 'summary.total_features', null);
        let summaryHtml = '';
        if (generatedAt) summaryHtml += `<p><strong>Generated at:</strong> ${formatISO(generatedAt)}</p>`;
        if (totalFeatures !== null) summaryHtml += `<p><strong>Total features:</strong> ${totalFeatures}</p>`;
        summaryContentEl.innerHTML = summaryHtml || '<p class="muted">No summary fields present.</p>';
        summaryEl.hidden = false;

        // Features/Gaps tags
        const features = Array.isArray(data.features) ? data.features : null;
        const gaps = Array.isArray(data.gaps) ? data.gaps : null;
        if (features || gaps) {
          let fgHtml = '';
          if (features) fgHtml += `<span class="tag">Features: ${features.length}</span>`;
          if (gaps) fgHtml += `<span class="tag">Gaps: ${gaps.length}</span>`;
          featuresGapsContentEl.innerHTML = fgHtml;
          featuresGapsEl.hidden = false;
        }

        // Executive summary
        const tsTotal = safeGet(data, 'time_series.total', null);
        const sources = safeGet(data, 'source_breakdown.sources', []);
        const productAreas = safeGet(data, 'product_area_breakdown.product_areas', []);
        let execHtml = '';
        if (tsTotal !== null) execHtml += `<p><strong>Total detected items (time series):</strong> ${tsTotal}</p>`;
        if (Array.isArray(sources) && sources.length) {
          const topSrc = [...sources].sort((a,b) => (b.count||0)-(a.count||0))[0];
          execHtml += `<p><strong>Top source:</strong> ${topSrc?.name || 'n/a'} (${topSrc?.count ?? 0})</p>`;
        }
        if (Array.isArray(productAreas) && productAreas.length) {
          const topArea = [...productAreas].sort((a,b) => (b.count||0)-(a.count||0))[0];
          execHtml += `<p><strong>Top product area:</strong> ${topArea?.name || 'n/a'} (${topArea?.count ?? 0})</p>`;
        }
        executiveContentEl.innerHTML = execHtml || '<p class="muted">No executive summary fields available.</p>';
        executiveEl.hidden = false;

        // Gaps details + immediate steps
        if (Array.isArray(gaps) && gaps.length) {
          renderTableRows(gapsBodyEl, gaps, ['name', 'impact', 'area']);
          gapsSectionEl.hidden = false;
          immediateStepsEl.innerHTML = buildImmediateSteps(gaps);
        }

        // Time series table
        const tsRows = safeGet(data, 'time_series.time_series', []);
        if (Array.isArray(tsRows) && tsRows.length) {
          renderTableRows(timeSeriesBodyEl, tsRows, ['date', 'count', 'cumulative']);
          timeSeriesEl.hidden = false;
        }

        // Source breakdown table (counts link to Learn paths when available)
        if (Array.isArray(sources) && sources.length) {
          renderSourceBreakdownWithLinks(sourceBreakdownBodyEl, sources, map);
          sourceBreakdownEl.hidden = false;
        }

        // Product area breakdown table
        if (Array.isArray(productAreas) && productAreas.length) {
          renderTableRows(productAreaBreakdownBodyEl, productAreas, ['name', 'count']);
          productAreaBreakdownEl.hidden = false;
        }

        // Learn Alignment cards
        if (map) {
          const cards = computeLearnAlignment(data, map);
          learnGridEl.innerHTML = cards.map(c => `
            <div class="card">
              <h3>${c.name}</h3>
              <p><strong>Items:</strong> ${c.count}</p>
              ${c.link ? `<p class="small"><a href="${c.link}" target="_blank" rel="noopener">Recommended learning path</a></p>` : ''}
            </div>
          `).join('');
          learnAlignmentEl.hidden = false;
        }
      } catch (e) {
        statusEl.innerHTML = `<strong class="error">Error loading dashboard.json:</strong> ${e}`;
      }
    }

    loadDashboard();
  </script>
</body>
</html>
