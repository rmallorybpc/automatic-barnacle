"""GitHub issues management for feature gaps."""
import os
import json
from typing import List, Dict, Optional
import yaml

from .models import Feature
from .utils import setup_logging, validate_file_exists, safe_request


logger = setup_logging(__name__)


class IssuesManager:
    """Manage GitHub issues for feature gaps."""
    
    def __init__(self, config_path: str = "config.yaml"):
        """Initialize with configuration."""
        with open(config_path, 'r') as f:
            self.config = yaml.safe_load(f)
        
        self.issue_config = self.config.get('issue', {})
        self.repo = self.issue_config.get('repo', '')
        self.labels = self.issue_config.get('labels', [])
        self.assignees = self.issue_config.get('assignees', [])
    
    def load_report(self, report_path: str = "data/reports/report.json") -> Dict:
        """Load report data."""
        if not validate_file_exists(report_path, logger):
            return {}
        
        try:
            with open(report_path, 'r') as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Failed to load report: {e}")
            return {}
    
    def create_issue_body(self, feature: Feature) -> str:
        """Create issue body for a feature.
        
        Args:
            feature: Feature object
            
        Returns:
            Markdown formatted issue body
        """
        body = f"## Feature Gap Detected\n\n"
        body += f"**Feature:** {feature.title}\n\n"
        body += f"**Description:**\n{feature.description}\n\n"
        body += f"**Source:** {feature.source_type}\n"
        if feature.source_url:
            body += f"**URL:** {feature.source_url}\n"
        body += f"**Product Area:** {feature.product_area}\n"
        if feature.tags:
            body += f"**Tags:** {', '.join(feature.tags)}\n"
        body += f"\n**Discovered:** {feature.date_discovered}\n\n"
        body += "---\n"
        body += "*This issue was automatically generated by the feature monitoring system.*\n"
        
        return body
    
    def check_existing_issue(self, feature: Feature) -> Optional[str]:
        """Check if an issue already exists for this feature.
        
        Args:
            feature: Feature object
            
        Returns:
            Issue URL if exists, None otherwise
        """
        if not self.repo:
            logger.error("No repository configured for issues")
            return None
        
        # In production, would use GitHub API to search for existing issues
        # For now, just log the check
        logger.info(f"Checking for existing issue: {feature.title}")
        return None
    
    def create_issue(self, feature: Feature) -> Optional[str]:
        """Create a GitHub issue for a feature.
        
        Args:
            feature: Feature object
            
        Returns:
            Issue URL if created, None on failure
        """
        if not self.repo:
            logger.error("No repository configured for issues")
            return None
        
        # Check if issue already exists
        existing = self.check_existing_issue(feature)
        if existing:
            logger.info(f"Issue already exists: {existing}")
            return existing
        
        title = f"Feature Gap: {feature.title}"
        body = self.create_issue_body(feature)
        
        # In production, would use GitHub API to create issue
        # For now, just log the creation
        logger.info(f"Would create issue: {title}")
        logger.info(f"Repository: {self.repo}")
        logger.info(f"Labels: {self.labels}")
        
        # Mock URL
        issue_url = f"https://github.com/{self.repo}/issues/123"
        return issue_url
    
    def process_features(self, features: List[Feature]) -> Dict:
        """Process features and create issues as needed.
        
        Args:
            features: List of Feature objects
            
        Returns:
            Summary of issues created
        """
        logger.info(f"Processing {len(features)} features for issue creation")
        
        summary = {
            'total': len(features),
            'created': 0,
            'existing': 0,
            'failed': 0,
            'issues': []
        }
        
        for feature in features:
            try:
                issue_url = self.create_issue(feature)
                if issue_url:
                    summary['created'] += 1
                    summary['issues'].append({
                        'feature_id': feature.id,
                        'feature_title': feature.title,
                        'issue_url': issue_url
                    })
                else:
                    summary['failed'] += 1
            except Exception as e:
                logger.error(f"Failed to process feature {feature.id}: {e}")
                summary['failed'] += 1
        
        logger.info(f"Issues summary: {summary['created']} created, {summary['failed']} failed")
        return summary
    
    def save_issues_summary(
        self,
        summary: Dict,
        output_path: str = "data/issues/summary.json"
    ) -> bool:
        """Save issues summary.
        
        Args:
            summary: Issues summary
            output_path: Path to output file
            
        Returns:
            True on success, False on failure
        """
        try:
            os.makedirs(os.path.dirname(output_path), exist_ok=True)
            
            with open(output_path, 'w') as f:
                json.dump(summary, f, indent=2)
            
            logger.info(f"Saved issues summary to {output_path}")
            return True
        except Exception as e:
            logger.error(f"Failed to save issues summary: {e}")
            return False


def main():
    """Main entry point for issues management."""
    import sys
    
    try:
        manager = IssuesManager()
        
        # Load features from report
        report = manager.load_report()
        if not report or 'features' not in report:
            logger.error("No report data found")
            return 1
        
        features = [Feature.from_dict(f) for f in report['features']]
        
        summary = manager.process_features(features)
        
        if not manager.save_issues_summary(summary):
            logger.error("Failed to save issues summary")
            return 1
        
        print(f"\nIssues Management Summary:")
        print(f"  Total features: {summary['total']}")
        print(f"  Issues created: {summary['created']}")
        print(f"  Failed: {summary['failed']}")
        
        return 0
    except Exception as e:
        logger.error(f"Issues management failed: {e}", exc_info=True)
        return 1


if __name__ == "__main__":
    import sys
    sys.exit(main())
